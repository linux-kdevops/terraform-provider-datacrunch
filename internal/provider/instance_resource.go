// Code generated by manual implementation. DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/squat/terraform-provider-datacrunch/internal/sdk"
	"github.com/squat/terraform-provider-datacrunch/internal/sdk/pkg/models/operations"
	"github.com/squat/terraform-provider-datacrunch/internal/sdk/pkg/models/shared"
)

var (
	_ resource.Resource                = &InstanceResource{}
	_ resource.ResourceWithConfigure   = &InstanceResource{}
	_ resource.ResourceWithImportState = &InstanceResource{}
)

func NewInstanceResource() resource.Resource {
	return &InstanceResource{}
}

type InstanceResource struct {
	client *sdk.SDK
}

type InstanceResourceModel struct {
	ID               types.String `tfsdk:"id"`
	Hostname         types.String `tfsdk:"hostname"`
	Description      types.String `tfsdk:"description"`
	Image            types.String `tfsdk:"image"`
	InstanceType     types.String `tfsdk:"instance_type"`
	LocationCode     types.String `tfsdk:"location_code"`
	SSHKeyIDs        types.List   `tfsdk:"ssh_key_ids"`
	IP               types.String `tfsdk:"ip"`
	Status           types.String `tfsdk:"status"`
	CreatedAt        types.String `tfsdk:"created_at"`
	PricePerHour     types.Float64 `tfsdk:"price_per_hour"`
	StartupScriptID  types.String `tfsdk:"startup_script_id"`
}

func (r *InstanceResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_instance"
}

func (r *InstanceResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "DataCrunch instance resource",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				MarkdownDescription: "Instance ID",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"hostname": schema.StringAttribute{
				MarkdownDescription: "Instance hostname",
				Required:            true,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Instance description",
				Required:            true,
			},
			"image": schema.StringAttribute{
				MarkdownDescription: "Operating system image type",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"instance_type": schema.StringAttribute{
				MarkdownDescription: "Instance type (e.g., 1H100.80S.30V)",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"location_code": schema.StringAttribute{
				MarkdownDescription: "Datacenter location code",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"ssh_key_ids": schema.ListAttribute{
				MarkdownDescription: "List of SSH key IDs",
				ElementType:         types.StringType,
				Required:            true,
			},
			"ip": schema.StringAttribute{
				MarkdownDescription: "Instance IP address",
				Computed:            true,
			},
			"status": schema.StringAttribute{
				MarkdownDescription: "Instance status",
				Computed:            true,
			},
			"created_at": schema.StringAttribute{
				MarkdownDescription: "Instance creation timestamp",
				Computed:            true,
			},
			"price_per_hour": schema.Float64Attribute{
				MarkdownDescription: "Instance hourly price",
				Computed:            true,
			},
			"startup_script_id": schema.StringAttribute{
				MarkdownDescription: "Startup script ID",
				Optional:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (r *InstanceResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.SDK)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.SDK, got: %T", req.ProviderData),
		)
		return
	}

	r.client = client
}

func (r *InstanceResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan InstanceResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Convert SSH key IDs from Terraform list to []string
	var sshKeyIDs []string
	resp.Diagnostics.Append(plan.SSHKeyIDs.ElementsAs(ctx, &sshKeyIDs, false)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Build deploy request
	deployReq := shared.DeployInstance{
		Hostname:     plan.Hostname.ValueString(),
		Description:  plan.Description.ValueString(),
		Image:        shared.CreateDeployInstanceImageStr(plan.Image.ValueString()),
		InstanceType: shared.InstanceType(plan.InstanceType.ValueString()),
		SSHKeyIds:    shared.CreateSSHKeyIdsArrayOfstr(sshKeyIDs),
	}

	// Add optional location code
	if !plan.LocationCode.IsNull() && !plan.LocationCode.IsUnknown() {
		locCode := shared.LocationCode(plan.LocationCode.ValueString())
		deployReq.LocationCode = &locCode
	}

	// Add optional startup script ID
	if !plan.StartupScriptID.IsNull() && !plan.StartupScriptID.IsUnknown() {
		scriptID := plan.StartupScriptID.ValueString()
		deployReq.StartupScriptID = &scriptID
	}

	// Deploy the instance
	deployResp, err := r.client.Instances.DeployInstance(ctx, deployReq)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error deploying instance",
			fmt.Sprintf("Could not deploy instance: %s", err.Error()),
		)
		return
	}

	if deployResp.StatusCode != 201 && deployResp.StatusCode != 200 && deployResp.StatusCode != 202 {
		resp.Diagnostics.AddError(
			"Error deploying instance",
			fmt.Sprintf("API returned status %d", deployResp.StatusCode),
		)
		return
	}

	if deployResp.InstanceID == nil {
		resp.Diagnostics.AddError(
			"Error deploying instance",
			"API did not return instance ID",
		)
		return
	}

	// Wait for instance to be fully provisioned with an IP
	instanceID := *deployResp.InstanceID
	getInstance, err := r.waitForInstanceReady(ctx, instanceID)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error waiting for instance to be ready",
			fmt.Sprintf("Instance %s did not become ready: %s", instanceID, err.Error()),
		)
		return
	}

	// Preserve the location_code from plan if it was explicitly set
	// The API may provision in a different location than requested
	planLocationCode := plan.LocationCode

	// Update state with response data
	r.updateStateFromInstance(ctx, &plan, getInstance.Instance, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	// Restore the location_code from plan if it was explicitly set
	// to avoid Terraform detecting it as an inconsistent result
	if !planLocationCode.IsNull() && !planLocationCode.IsUnknown() {
		plan.LocationCode = planLocationCode
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

// waitForInstanceReady polls the instance until it has an IP address assigned
func (r *InstanceResource) waitForInstanceReady(ctx context.Context, instanceID string) (*operations.GetInstanceByIDResponse, error) {
	timeout := time.After(10 * time.Minute)
	ticker := time.NewTicker(10 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-timeout:
			return nil, fmt.Errorf("timeout waiting for instance to be ready")
		case <-ticker.C:
			getInstance, err := r.client.Instances.GetInstanceByID(ctx, operations.GetInstanceByIDRequest{
				InstanceID: instanceID,
			})
			if err != nil {
				return nil, fmt.Errorf("could not read instance: %w", err)
			}

			// Check if instance has an IP address
			if getInstance.Instance != nil && getInstance.Instance.IP != nil && *getInstance.Instance.IP != "" {
				return getInstance, nil
			}

			// Check for error states
			if getInstance.Instance != nil && getInstance.Instance.Status != nil {
				status := string(*getInstance.Instance.Status)
				if status == "error" || status == "no_capacity" {
					return nil, fmt.Errorf("instance provisioning failed with status: %s", status)
				}
			}
		}
	}
}

func (r *InstanceResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state InstanceResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	getInstance, err := r.client.Instances.GetInstanceByID(ctx, operations.GetInstanceByIDRequest{
		InstanceID: state.ID.ValueString(),
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Error reading instance",
			fmt.Sprintf("Could not read instance %s: %s", state.ID.ValueString(), err.Error()),
		)
		return
	}

	if getInstance.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}

	r.updateStateFromInstance(ctx, &state, getInstance.Instance, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

func (r *InstanceResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	// DataCrunch instances cannot be updated in place
	// Changes to image, instance_type, location_code require replacement (handled by RequiresReplace plan modifiers)
	// hostname, description, and ssh_key_ids updates are not supported by the API
	resp.Diagnostics.AddWarning(
		"Update Not Supported",
		"DataCrunch instances cannot be updated. Changes to most attributes require instance replacement.",
	)
}

func (r *InstanceResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state InstanceResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Create delete action request
	idUnion := operations.CreateIDStr(state.ID.ValueString())
	actionReq := operations.InstanceActionRequestBody{
		Action: shared.ActionTypeDelete,
		ID:     idUnion,
	}

	_, err := r.client.Instances.InstanceAction(ctx, actionReq)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error deleting instance",
			fmt.Sprintf("Could not delete instance %s: %s", state.ID.ValueString(), err.Error()),
		)
		return
	}

	// Wait for instance to be fully deleted
	err = r.waitForInstanceDeleted(ctx, state.ID.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Error waiting for instance deletion",
			fmt.Sprintf("Instance %s did not complete deletion: %s", state.ID.ValueString(), err.Error()),
		)
		return
	}
}

// waitForInstanceDeleted polls until the instance is gone (404)
func (r *InstanceResource) waitForInstanceDeleted(ctx context.Context, instanceID string) error {
	timeout := time.After(5 * time.Minute)
	ticker := time.NewTicker(5 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-timeout:
			return fmt.Errorf("timeout waiting for instance to be deleted")
		case <-ticker.C:
			getInstance, err := r.client.Instances.GetInstanceByID(ctx, operations.GetInstanceByIDRequest{
				InstanceID: instanceID,
			})

			// If we get a 404, the instance is deleted
			if err != nil || getInstance.StatusCode == 404 {
				return nil
			}

			// Instance still exists, keep waiting
		}
	}
}

func (r *InstanceResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}

func (r *InstanceResource) updateStateFromInstance(ctx context.Context, state *InstanceResourceModel, instance *shared.Instance, diags *diag.Diagnostics) {
	if instance.ID != nil {
		state.ID = types.StringValue(*instance.ID)
	}
	if instance.Hostname != nil {
		state.Hostname = types.StringValue(*instance.Hostname)
	}
	if instance.Description != nil {
		state.Description = types.StringValue(*instance.Description)
	}
	if instance.Image != nil {
		state.Image = types.StringValue(string(*instance.Image))
	}
	if instance.InstanceType != nil {
		state.InstanceType = types.StringValue(string(*instance.InstanceType))
	}
	if instance.LocationCode != nil {
		state.LocationCode = types.StringValue(string(*instance.LocationCode))
	}
	if instance.IP != nil {
		state.IP = types.StringValue(*instance.IP)
	}
	if instance.Status != nil {
		state.Status = types.StringValue(string(*instance.Status))
	}
	if instance.CreatedAt != nil {
		state.CreatedAt = types.StringValue(*instance.CreatedAt)
	}
	if instance.PricePerHour != nil {
		state.PricePerHour = types.Float64Value(*instance.PricePerHour)
	}
	if instance.StartupScriptID != nil {
		state.StartupScriptID = types.StringValue(*instance.StartupScriptID)
	}

	// Convert SSH key IDs
	if len(instance.SSHKeyIds) > 0 {
		sshKeyList, d := types.ListValueFrom(ctx, types.StringType, instance.SSHKeyIds)
		diags.Append(d...)
		state.SSHKeyIDs = sshKeyList
	}
}
