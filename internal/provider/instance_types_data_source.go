// Code generated by manual implementation. DO NOT EDIT.

package provider

import (
	"context"
	"encoding/json"
	"fmt"
	"io"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/squat/terraform-provider-datacrunch/internal/sdk"
)

var (
	_ datasource.DataSource              = &InstanceTypesDataSource{}
	_ datasource.DataSourceWithConfigure = &InstanceTypesDataSource{}
)

func NewInstanceTypesDataSource() datasource.DataSource {
	return &InstanceTypesDataSource{}
}

type InstanceTypesDataSource struct {
	client *sdk.SDK
}

type InstanceTypesDataSourceModel struct {
	InstanceTypes []InstanceTypeModel `tfsdk:"instance_types"`
}

type InstanceTypeModel struct {
	InstanceType types.String  `tfsdk:"instance_type"`
	Description  types.String  `tfsdk:"description"`
	CPU          types.String  `tfsdk:"cpu"`
	Memory       types.Int64   `tfsdk:"memory"`
	GPU          types.String  `tfsdk:"gpu"`
	Storage      types.Int64   `tfsdk:"storage"`
	PricePerHour types.Float64 `tfsdk:"price_per_hour"`
}

func (d *InstanceTypesDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_instance_types"
}

func (d *InstanceTypesDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "DataCrunch instance types data source",
		Attributes: map[string]schema.Attribute{
			"instance_types": schema.ListNestedAttribute{
				MarkdownDescription: "List of available instance types",
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"instance_type": schema.StringAttribute{
							MarkdownDescription: "Instance type identifier",
							Computed:            true,
						},
						"description": schema.StringAttribute{
							MarkdownDescription: "Instance type description",
							Computed:            true,
						},
						"cpu": schema.StringAttribute{
							MarkdownDescription: "CPU specification",
							Computed:            true,
						},
						"memory": schema.Int64Attribute{
							MarkdownDescription: "Memory in GB",
							Computed:            true,
						},
						"gpu": schema.StringAttribute{
							MarkdownDescription: "GPU specification",
							Computed:            true,
						},
						"storage": schema.Int64Attribute{
							MarkdownDescription: "Storage in GB",
							Computed:            true,
						},
						"price_per_hour": schema.Float64Attribute{
							MarkdownDescription: "Price per hour in USD",
							Computed:            true,
						},
					},
				},
			},
		},
	}
}

func (d *InstanceTypesDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.SDK)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Data Source Configure Type",
			fmt.Sprintf("Expected *sdk.SDK, got: %T", req.ProviderData),
		)
		return
	}

	d.client = client
}

func (d *InstanceTypesDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state InstanceTypesDataSourceModel

	// Call the API
	apiResp, err := d.client.InstanceTypes.GetInstancesTypes(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error reading instance types",
			fmt.Sprintf("Could not read instance types: %s", err.Error()),
		)
		return
	}

	if apiResp.StatusCode != 200 {
		resp.Diagnostics.AddError(
			"Error reading instance types",
			fmt.Sprintf("API returned status %d", apiResp.StatusCode),
		)
		return
	}

	// Parse the response body manually
	body, err := io.ReadAll(apiResp.RawResponse.Body)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error reading response body",
			fmt.Sprintf("Could not read response: %s", err.Error()),
		)
		return
	}

	var instanceTypes []map[string]interface{}
	if err := json.Unmarshal(body, &instanceTypes); err != nil {
		resp.Diagnostics.AddError(
			"Error parsing response",
			fmt.Sprintf("Could not parse JSON: %s", err.Error()),
		)
		return
	}

	// Convert to model
	state.InstanceTypes = make([]InstanceTypeModel, 0, len(instanceTypes))
	for _, it := range instanceTypes {
		model := InstanceTypeModel{}

		if v, ok := it["instance_type"].(string); ok {
			model.InstanceType = types.StringValue(v)
		}
		if v, ok := it["description"].(string); ok {
			model.Description = types.StringValue(v)
		}
		if v, ok := it["cpu"].(string); ok {
			model.CPU = types.StringValue(v)
		}
		if v, ok := it["memory"].(float64); ok {
			model.Memory = types.Int64Value(int64(v))
		}
		if v, ok := it["gpu"].(string); ok {
			model.GPU = types.StringValue(v)
		}
		if v, ok := it["storage"].(float64); ok {
			model.Storage = types.Int64Value(int64(v))
		}
		if v, ok := it["price_per_hour"].(float64); ok {
			model.PricePerHour = types.Float64Value(v)
		} else if v, ok := it["price_per_hour"].(string); ok {
			// Handle string price
			var price float64
			fmt.Sscanf(v, "%f", &price)
			model.PricePerHour = types.Float64Value(price)
		}

		state.InstanceTypes = append(state.InstanceTypes, model)
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
